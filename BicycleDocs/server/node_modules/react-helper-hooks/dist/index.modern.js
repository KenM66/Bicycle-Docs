import { useState, useCallback, useEffect, useRef } from 'react';

function useToggle(defaultValue) {
  var _useState = useState(defaultValue),
      value = _useState[0],
      setValue = _useState[1];

  function toggleValue(value) {
    setValue(function (currentValue) {
      return typeof value === "boolean" ? value : !currentValue;
    });
  }

  return [value, toggleValue];
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function useAsync(callback, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }

  var _useState = useState(true),
      loading = _useState[0],
      setLoading = _useState[1];

  var _useState2 = useState(),
      error = _useState2[0],
      setError = _useState2[1];

  var _useState3 = useState(),
      value = _useState3[0],
      setValue = _useState3[1];

  var callbackMemoized = useCallback(function () {
    setLoading(true);
    setError(undefined);
    setValue(undefined);
    callback().then(setValue)["catch"](setError)["finally"](function () {
      return setLoading(false);
    });
  }, dependencies);
  useEffect(function () {
    callbackMemoized();
  }, [callbackMemoized]);
  return {
    loading: loading,
    error: error,
    value: value
  };
}

var DEFAULT_OPTIONS = {
  headers: {
    "Content-Type": "application/json"
  }
};
function useFetch(url, options, dependencies) {
  if (options === void 0) {
    options = {};
  }

  if (dependencies === void 0) {
    dependencies = [];
  }

  return useAsync(function () {
    return fetch(url, _extends({}, DEFAULT_OPTIONS, options)).then(function (res) {
      if (res.ok) return res.json();
      return res.json().then(function (json) {
        return Promise.reject(json);
      });
    });
  }, dependencies);
}

function useIsAppOffline() {
  var _useState = useState(!navigator.onLine),
      isAppOffline = _useState[0],
      setIsAppOffline = _useState[1];

  window.addEventListener('online', function (e) {
    setIsAppOffline(false);
  });
  window.addEventListener('offline', function (e) {
    setIsAppOffline(true);
  });
  return isAppOffline;
}

function getWindowDimensions() {
  var _window = window,
      width = _window.innerWidth,
      height = _window.innerHeight;
  return {
    isMobile: width <= 480,
    isTablet: width >= 481 && width <= 768,
    isLaptop: width >= 769 && width <= 1024,
    isDesktop: width >= 1025 && width <= 1200,
    isExtraLarge: width >= 1201,
    width: width,
    height: height
  };
}

function useWindowDimensions() {
  var _useState = useState(getWindowDimensions()),
      windowDimensions = _useState[0],
      setWindowDimensions = _useState[1];

  useEffect(function () {
    function handleResize() {
      setWindowDimensions(getWindowDimensions());
    }

    window.addEventListener('resize', handleResize);
    return function () {
      return window.removeEventListener('resize', handleResize);
    };
  }, []);
  return windowDimensions;
}

function useScript(url) {
  return useAsync(function () {
    var script = document.createElement("script");
    script.src = url;
    script.async = true;
    return new Promise(function (resolve, reject) {
      script.addEventListener("load", resolve);
      script.addEventListener("error", reject);
      document.body.appendChild(script);
    });
  }, [url]);
}

function useEventListener(eventType, callback, element) {
  if (element === void 0) {
    element = window;
  }

  var callbackRef = useRef(callback);
  useEffect(function () {
    callbackRef.current = callback;
  }, [callback]);
  useEffect(function () {
    var handler = function handler(e) {
      return callbackRef.current(e);
    };

    element.addEventListener(eventType, handler);
    return function () {
      return element.removeEventListener(eventType, handler);
    };
  }, [eventType, element]);
}

function useOnScreen(ref, rootMargin) {
  if (rootMargin === void 0) {
    rootMargin = "0px";
  }

  var _useState = useState(false),
      isVisible = _useState[0],
      setIsVisible = _useState[1];

  useEffect(function () {
    if (ref.current == null) return;
    var observer = new IntersectionObserver(function (_ref) {
      var entry = _ref[0];
      return setIsVisible(entry.isIntersecting);
    }, {
      rootMargin: rootMargin
    });
    observer.observe(ref.current);
    return function () {
      if (ref.current == null) return;
      observer.unobserve(ref.current);
    };
  }, [ref.current, rootMargin]);
  return isVisible;
}

function useTimeout(callback, delay) {
  var callbackRef = useRef(callback);
  var timeoutRef = useRef();
  useEffect(function () {
    callbackRef.current = callback;
  }, [callback]);
  var set = useCallback(function () {
    timeoutRef.current = setTimeout(function () {
      return callbackRef.current();
    }, delay);
  }, [delay]);
  var clear = useCallback(function () {
    timeoutRef.current && clearTimeout(timeoutRef.current);
  }, []);
  useEffect(function () {
    set();
    return clear;
  }, [delay, set, clear]);
  var reset = useCallback(function () {
    clear();
    set();
  }, [clear, set]);
  return {
    reset: reset,
    clear: clear
  };
}

function useDebounce(callback, delay, dependencies) {
  var _useTimeout = useTimeout(callback, delay),
      reset = _useTimeout.reset,
      clear = _useTimeout.clear;

  useEffect(reset, [].concat(dependencies, [reset]));
  useEffect(clear, []);
}

function useUpdateEffect(callback, dependencies) {
  var firstRendererRef = useRef(true);
  useEffect(function () {
    if (firstRendererRef.current) {
      firstRendererRef.current = false;
      return;
    }

    return callback();
  }, [dependencies]);
}

function useArray(defaultValue) {
  var _useState = useState(defaultValue),
      array = _useState[0],
      setArray = _useState[1];

  function push(element) {
    setArray(function (a) {
      return [].concat(a, [element]);
    });
  }

  function filter(callback) {
    setArray(function (a) {
      return a.filter(callback);
    });
  }

  function update(index, newElement) {
    setArray(array.splice(index, 1, newElement) && [].concat(array));
  }

  function remove(index) {
    setArray(array.filter(function (_, i) {
      return index !== i;
    }));
  }

  function clear() {
    setArray([]);
  }

  return {
    array: array,
    set: setArray,
    push: push,
    filter: filter,
    update: update,
    remove: remove,
    clear: clear
  };
}

function usePrevious(value) {
  var currentRef = useRef(value);
  var previousRef = useRef();

  if (currentRef.current !== value) {
    previousRef.current = currentRef.current;
    currentRef.current = value;
  }

  return previousRef.current;
}

function useStateWithHistory(defaultValue, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$capacity = _ref.capacity,
      capacity = _ref$capacity === void 0 ? 10 : _ref$capacity;

  var _useState = useState(defaultValue),
      value = _useState[0],
      setValue = _useState[1];

  var historyRef = useRef([value]);
  var pointerRef = useRef(0);
  var set = useCallback(function (v) {
    var resolvedValue = typeof v === "function" ? v(value) : v;

    if (historyRef.current[pointerRef.current] !== resolvedValue) {
      if (pointerRef.current < historyRef.current.length - 1) {
        historyRef.current.splice(pointerRef.current + 1);
      }

      historyRef.current.push(resolvedValue);

      while (historyRef.current.length > capacity) {
        historyRef.current.shift();
      }

      pointerRef.current = historyRef.current.length - 1;
    }

    setValue(resolvedValue);
  }, [capacity, value]);
  var back = useCallback(function () {
    if (pointerRef.current <= 0) return;
    pointerRef.current--;
    setValue(historyRef.current[pointerRef.current]);
  }, []);
  var forward = useCallback(function () {
    if (pointerRef.current >= historyRef.current.length - 1) return;
    pointerRef.current++;
    setValue(historyRef.current[pointerRef.current]);
  }, []);
  var go = useCallback(function (index) {
    if (index < 0 || index >= historyRef.current.length - 1) return;
    pointerRef.current = index;
    setValue(historyRef.current[pointerRef.current]);
  }, []);
  return [value, set, {
    history: historyRef.current,
    pointer: pointerRef.current,
    back: back,
    forward: forward,
    go: go
  }];
}

function useLocalStorage(key, defaultValue) {
  return useStorage(key, defaultValue, window.localStorage);
}
function useSessionStorage(key, defaultValue) {
  return useStorage(key, defaultValue, window.sessionStorage);
}

function useStorage(key, defaultValue, storageObject) {
  var _useState = useState(function () {
    var jsonValue = storageObject.getItem(key);
    if (jsonValue !== null) return JSON.parse(jsonValue);

    if (typeof jsonValue === "function") {
      return defaultValue();
    } else {
      return defaultValue;
    }
  }),
      value = _useState[0],
      setValue = _useState[1];

  useEffect(function () {
    if (value === undefined) return storageObject.removeItem(key);
    storageObject.setItem(key, JSON.stringify(value));
  }, [key, value, storageObject]);
  var remove = useCallback(function () {
    setValue(undefined);
  }, []);
  return [value, setValue, remove];
}

export { useArray, useAsync, useDebounce, useEventListener, useFetch, useIsAppOffline, useLocalStorage, useOnScreen, usePrevious, useScript, useSessionStorage, useStateWithHistory, useTimeout, useToggle, useUpdateEffect, useWindowDimensions };
//# sourceMappingURL=index.modern.js.map
